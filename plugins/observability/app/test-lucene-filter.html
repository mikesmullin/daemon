<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lucene Filter Test</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  
  <!-- Alpine.js for reactivity -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  
  <!-- Web Components -->
  <script type="module" src="/components/lucene-filter.mjs"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      padding: 2rem;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      margin-bottom: 2rem;
      color: #00d4ff;
    }
    
    .test-section {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    
    .test-section h2 {
      font-size: 1.25rem;
      margin-bottom: 1rem;
      color: #00d4ff;
    }
    
    .event-list {
      margin-top: 1.5rem;
    }
    
    .event-item {
      background: #0f0f0f;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 0.75rem;
    }
    
    .event-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    
    .event-type {
      font-weight: 600;
      color: #00d4ff;
    }
    
    .event-meta {
      font-size: 0.875rem;
      color: #888;
      font-family: 'JetBrains Mono', monospace;
    }
    
    .event-content {
      color: #e0e0e0;
      margin-top: 0.5rem;
    }
    
    .stats {
      margin-top: 1rem;
      padding: 1rem;
      background: #0f0f0f;
      border-radius: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
    }
    
    .exclude-btn {
      background: #2a2a2a;
      border: 1px solid #444;
      color: #888;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      transition: all 0.2s;
    }
    
    .exclude-btn:hover {
      background: #333;
      color: #00d4ff;
    }
    
    .test-buttons {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
      flex-wrap: wrap;
    }
    
    .test-btn {
      background: #00d4ff;
      color: #000;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    .test-btn:hover {
      background: #00b8e6;
    }
  </style>
</head>
<body>
  <div class="container" x-data="testApp()">
    <h1>üîç Lucene Filter Test Suite</h1>
    
    <div class="test-section">
      <h2>Filter Component</h2>
      <lucene-filter
        :filter="filter"
        @filter-change="handleFilterChange($event)"
        @filter-clear="handleFilterClear()">
      </lucene-filter>
      
      <div class="stats">
        <strong>Total Events:</strong> <span x-text="sampleEvents.length"></span><br>
        <strong>Filtered Events:</strong> <span x-text="filteredEvents.length"></span><br>
        <strong>Current Filter:</strong> <code x-text="filter || '(none)'"></code>
      </div>
    </div>
    
    <div class="test-section">
      <h2>Test Filters</h2>
      <div class="test-buttons">
        <button class="test-btn" @click="setFilter('session:12')">session:12</button>
        <button class="test-btn" @click="setFilter('agent:alice')">agent:alice</button>
        <button class="test-btn" @click="setFilter('tool:execute_shell')">tool:execute_shell</button>
        <button class="test-btn" @click="setFilter('type:TOOL_CALL')">type:TOOL_CALL</button>
        <button class="test-btn" @click="setFilter('session:12 AND tool:ask_human')">session:12 AND tool:ask_human</button>
        <button class="test-btn" @click="setFilter('agent:alice OR agent:bob')">agent:alice OR agent:bob</button>
        <button class="test-btn" @click="setFilter('NOT agent:charlie')">NOT agent:charlie</button>
        <button class="test-btn" @click="setFilter('session:* AND NOT tool:view_file')">session:* AND NOT tool:view_file</button>
      </div>
    </div>
    
    <div class="test-section">
      <h2>Events (<span x-text="filteredEvents.length"></span> shown)</h2>
      <div class="event-list">
        <template x-for="event in filteredEvents" :key="event.id">
          <div class="event-item">
            <div class="event-header">
              <div>
                <span class="event-type" x-text="event.type"></span>
                <span class="event-meta" x-text="`session:${event.session_id} agent:${event.agent}`"></span>
              </div>
              <div style="display: flex; gap: 0.5rem;">
                <button class="exclude-btn" @click="excludeField('session', event.session_id)" title="Exclude this session">
                  ‚àí session
                </button>
                <button class="exclude-btn" @click="excludeField('agent', event.agent)" title="Exclude this agent">
                  ‚àí agent
                </button>
                <button class="exclude-btn" @click="excludeField('type', event.type)" title="Exclude this type">
                  ‚àí type
                </button>
                <template x-if="event.tool">
                  <button class="exclude-btn" @click="excludeField('tool', event.tool)" title="Exclude this tool">
                    ‚àí tool
                  </button>
                </template>
              </div>
            </div>
            <div class="event-content" x-text="event.content"></div>
          </div>
        </template>
      </div>
    </div>
  </div>
  
  <script>
    function testApp() {
      return {
        filter: '',
        sampleEvents: [
          { id: 1, type: 'USER_REQUEST', session_id: 12, agent: 'alice', content: 'Please analyze this file', channel: 'dev' },
          { id: 2, type: 'TOOL_CALL', session_id: 12, agent: 'alice', tool: 'view_file', content: 'Reading file /workspace/README.md', channel: 'dev' },
          { id: 3, type: 'TOOL_RESPONSE', session_id: 12, agent: 'alice', tool: 'view_file', content: 'File content loaded', channel: 'dev' },
          { id: 4, type: 'RESPONSE', session_id: 12, agent: 'alice', content: 'Based on the file, I recommend...', channel: 'dev' },
          { id: 5, type: 'USER_REQUEST', session_id: 15, agent: 'bob', content: 'Run the tests', channel: 'dev' },
          { id: 6, type: 'TOOL_CALL', session_id: 15, agent: 'bob', tool: 'execute_shell', content: 'Running: npm test', channel: 'dev' },
          { id: 7, type: 'TOOL_RESPONSE', session_id: 15, agent: 'bob', tool: 'execute_shell', content: 'All tests passed ‚úì', channel: 'dev' },
          { id: 8, type: 'RESPONSE', session_id: 15, agent: 'bob', content: 'Tests completed successfully!', channel: 'dev' },
          { id: 9, type: 'TOOL_CALL', session_id: 23, agent: 'charlie', tool: 'ask_human', content: 'Should I proceed with deployment?', channel: 'dev' },
          { id: 10, type: 'USER_REQUEST', session_id: 23, agent: 'charlie', content: 'APPROVE', channel: 'dev' },
          { id: 11, type: 'TOOL_CALL', session_id: 12, agent: 'alice', tool: 'execute_shell', content: 'Running: git status', channel: 'dev' },
          { id: 12, type: 'TOOL_CALL', session_id: 7, agent: 'alice', tool: 'ask_human', content: 'Which approach should I use?', channel: 'test' },
        ],
        
        get filteredEvents() {
          if (!this.filter) {
            return this.sampleEvents;
          }
          
          try {
            // Use the same filtering logic as app.js
            const query = this.parseLuceneQuery(this.filter);
            return this.sampleEvents.filter(event => this.matchesQuery(event, query));
          } catch (err) {
            console.error('Filter error:', err);
            return this.sampleEvents;
          }
        },
        
        handleFilterChange(event) {
          this.filter = event.detail.filter;
        },
        
        handleFilterClear() {
          this.filter = '';
        },
        
        setFilter(filterStr) {
          this.filter = filterStr;
          // Update the component
          const component = document.querySelector('lucene-filter');
          if (component) {
            component.setAttribute('filter', filterStr);
          }
        },
        
        excludeField(field, value) {
          // Emit custom event that the filter component will catch
          window.dispatchEvent(new CustomEvent('filter-exclude', {
            detail: { field, value }
          }));
        },
        
        // Copy the same parsing logic from app.js
        parseLuceneQuery(queryStr) {
          const tokens = this.tokenizeLuceneQuery(queryStr);
          return this.parseTokens(tokens);
        },
        
        tokenizeLuceneQuery(queryStr) {
          const tokens = [];
          let current = '';
          let inQuotes = false;
          
          for (let i = 0; i < queryStr.length; i++) {
            const char = queryStr[i];
            
            if (char === '"') {
              inQuotes = !inQuotes;
              current += char;
            } else if (!inQuotes && /\s/.test(char)) {
              if (current) {
                tokens.push(current);
                current = '';
              }
            } else if (!inQuotes && (char === '(' || char === ')')) {
              if (current) {
                tokens.push(current);
                current = '';
              }
              tokens.push(char);
            } else {
              current += char;
            }
          }
          
          if (current) {
            tokens.push(current);
          }
          
          return tokens;
        },
        
        parseTokens(tokens) {
          const output = [];
          const operators = [];
          
          for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            if (token === '(') {
              operators.push(token);
            } else if (token === ')') {
              while (operators.length && operators[operators.length - 1] !== '(') {
                output.push(operators.pop());
              }
              operators.pop();
            } else if (token === 'AND' || token === 'OR') {
              while (operators.length && this.getPrecedence(operators[operators.length - 1]) >= this.getPrecedence(token)) {
                output.push(operators.pop());
              }
              operators.push(token);
            } else if (token === 'NOT') {
              operators.push(token);
            } else {
              output.push(this.parseTerm(token));
            }
          }
          
          while (operators.length) {
            output.push(operators.pop());
          }
          
          return this.buildQueryTree(output);
        },
        
        getPrecedence(op) {
          if (op === 'NOT') return 3;
          if (op === 'AND') return 2;
          if (op === 'OR') return 1;
          return 0;
        },
        
        parseTerm(token) {
          const colonIndex = token.indexOf(':');
          
          if (colonIndex > 0 && colonIndex < token.length - 1) {
            const field = token.substring(0, colonIndex);
            let value = token.substring(colonIndex + 1);
            
            if (value.startsWith('"') && value.endsWith('"')) {
              value = value.slice(1, -1);
            }
            
            return { type: 'term', field, value };
          } else {
            let value = token;
            if (value.startsWith('"') && value.endsWith('"')) {
              value = value.slice(1, -1);
            }
            return { type: 'term', field: '*', value };
          }
        },
        
        buildQueryTree(postfix) {
          const stack = [];
          
          for (const item of postfix) {
            if (typeof item === 'object' && item.type === 'term') {
              stack.push(item);
            } else if (item === 'NOT') {
              const operand = stack.pop();
              stack.push({ type: 'NOT', operand });
            } else if (item === 'AND' || item === 'OR') {
              const right = stack.pop();
              const left = stack.pop();
              stack.push({ type: item, left, right });
            }
          }
          
          return stack.length > 0 ? stack[0] : { type: 'term', field: '*', value: '' };
        },
        
        matchesQuery(event, query) {
          if (!query) return true;
          
          switch (query.type) {
            case 'term':
              return this.matchesTerm(event, query.field, query.value);
            case 'NOT':
              return !this.matchesQuery(event, query.operand);
            case 'AND':
              return this.matchesQuery(event, query.left) && this.matchesQuery(event, query.right);
            case 'OR':
              return this.matchesQuery(event, query.left) || this.matchesQuery(event, query.right);
            default:
              return true;
          }
        },
        
        matchesTerm(event, field, value) {
          const pattern = value.replace(/\*/g, '.*').replace(/\?/g, '.');
          const regex = new RegExp(`^${pattern}$`, 'i');
          
          if (field === '*') {
            const searchStr = JSON.stringify(event).toLowerCase();
            return searchStr.includes(value.toLowerCase());
          }
          
          let fieldValue = '';
          
          switch (field.toLowerCase()) {
            case 'session':
            case 'session_id':
              fieldValue = String(event.session_id || '');
              break;
            case 'agent':
            case 'agent_name':
              fieldValue = String(event.agent || '');
              break;
            case 'tool':
            case 'tool_name':
              fieldValue = String(event.tool || '');
              break;
            case 'type':
            case 'event_type':
              fieldValue = String(event.type || '');
              break;
            case 'content':
            case 'message':
              fieldValue = String(event.content || '');
              break;
            default:
              fieldValue = String(event[field] || '');
              break;
          }
          
          return regex.test(fieldValue);
        }
      };
    }
  </script>
</body>
</html>
