<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multi-Agent Observability Dashboard</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Alpine.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  
  <!-- Marked.js for Markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  
  <!-- Web Components -->
  <script type="module" src="/components/status-bar.mjs"></script>
  <script type="module" src="/components/agent-card.mjs"></script>
  <script type="module" src="/components/event-stream.mjs"></script>
  <script type="module" src="/components/event-item.mjs"></script>
  <script type="module" src="/components/orchestrator-panel.mjs"></script>
  <script type="module" src="/components/orchestrator-action.mjs"></script>
  <script type="module" src="/components/search-bar.mjs"></script>
  <script type="module" src="/components/auto-follow-toggle.mjs"></script>
  <script type="module" src="/components/chat-message.mjs"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #0f0f0f;
      color: #e0e0e0;
      overflow: hidden;
    }
    
    .dashboard-container {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .dashboard-main {
      flex: 1;
      display: flex;
      overflow: hidden;
      position: relative;
    }
    
    .agents-sidebar,
    .orchestrator-sidebar {
      background: #0f0f0f;
      overflow-y: auto;
      overflow-x: hidden;
      position: relative;
    }
    
    .agents-sidebar {
      border-right: 1px solid #333;
      min-width: 200px;
      max-width: 600px;
    }
    
    .orchestrator-sidebar {
      border-left: 1px solid #333;
      min-width: 200px;
      max-width: 600px;
    }
    
    .stream-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #0f0f0f;
      overflow: hidden;
    }
    
    .resize-handle {
      width: 5px;
      background: transparent;
      cursor: col-resize;
      position: absolute;
      top: 0;
      bottom: 0;
      z-index: 10;
      transition: background 0.2s;
    }
    
    .resize-handle:hover,
    .resize-handle.dragging {
      background: #00d4ff;
    }
    
    .resize-handle-left {
      right: -2px;
    }
    
    .resize-handle-right {
      left: -2px;
    }
    
    .agents-sidebar::-webkit-scrollbar,
    .orchestrator-sidebar::-webkit-scrollbar {
      width: 8px;
    }
    
    .agents-sidebar::-webkit-scrollbar-track,
    .orchestrator-sidebar::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    
    .agents-sidebar::-webkit-scrollbar-thumb,
    .orchestrator-sidebar::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 4px;
    }
    
    .agents-header,
    .stream-controls {
      padding: 1rem 1.5rem;
      background: #1a1a1a;
      border-bottom: 1px solid #333;
    }
    
    .section-title {
      font-size: 0.875rem;
      font-weight: 700;
      color: #e0e0e0;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .agents-list {
      padding: 1rem;
    }
    
    .stream-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #0f0f0f;
      overflow: hidden;
    }
    
    .stream-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }
    
    .filter-buttons {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .filter-button {
      padding: 0.375rem 0.75rem;
      border: 1px solid #444;
      background: #1a1a1a;
      color: #888;
      font-size: 0.6875rem;
      font-weight: 600;
      text-transform: uppercase;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 0.05em;
    }
    
    .filter-button:hover {
      background: #2a2a2a;
      border-color: #666;
      color: #e0e0e0;
    }
    
    .filter-button.active {
      background: #00d4ff22;
      border-color: #00d4ff;
      color: #00d4ff;
      box-shadow: 0 0 8px #00d4ff33;
    }
    
    .empty-agents {
      padding: 2rem 1rem;
      text-align: center;
      color: #666;
      font-size: 0.875rem;
    }
    
    .empty-agents-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      opacity: 0.5;
    }
    
    button {
      font-family: 'Inter', -apple-system, sans-serif;
    }
    
    .button {
      padding: 0.5rem 1rem;
      border: 1px solid #444;
      background: #2a2a2a;
      color: #e0e0e0;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
    }
    
    .button:hover {
      background: #333;
      border-color: #00d4ff;
      color: #00d4ff;
    }
    
    .chat-input-field {
      width: 100%;
      min-height: 80px;
      padding: 0.75rem;
      background: #0f0f0f;
      border: 2px solid #1a1a1a;
      border-radius: 8px;
      color: #e0e0e0;
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 0.875rem;
      resize: vertical;
      transition: all 0.3s ease;
      box-shadow: 0 0 0 0 rgba(0, 212, 255, 0);
    }
    
    .chat-input-field:focus {
      outline: none;
      border-color: #00d4ff;
      box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
    }
    
    .chat-input-field.chat-input-focused {
      border-color: #00d4ff;
      box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
    }
    
    .chat-input-field::placeholder {
      color: #555;
    }
    
    .send-button {
      background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
      color: #000;
      border: none;
      padding: 0.625rem 1.5rem;
      border-radius: 6px;
      font-weight: 600;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(0, 212, 255, 0.3);
    }
    
    .send-button:hover {
      background: linear-gradient(135deg, #00e5ff 0%, #00aadd 100%);
      box-shadow: 0 4px 12px rgba(0, 212, 255, 0.5);
      transform: translateY(-1px);
    }
    
    .send-button:active {
      transform: translateY(0);
    }
    
    .send-button.send-button-disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="dashboard-container" x-data="dashboard()">
    <!-- Status Bar -->
    <status-bar 
      :title="'MULTI-AGENT OBSERVABILITY'"
      :connection="connectionStatus"
      :active="metrics.activeAgents"
      :running="metrics.runningTasks"
      :logs="metrics.logCount"
      :cost="metrics.totalCost">
      <button slot="actions" class="button" @click="clearAll">CLEAR ALL</button>
      <button slot="actions" class="button" @click="openPrompt">PROMPT (Cmd+K)</button>
    </status-bar>
    
    <!-- Main Dashboard -->
    <div class="dashboard-main">
      <!-- Left Sidebar - Agents -->
      <div class="agents-sidebar" :style="`width: ${leftWidth}px`">
        <div class="resize-handle resize-handle-left" 
             @mousedown="startResize($event, 'left')"></div>
        <div class="agents-header">
          <div class="section-title">ACTIVE AGENTS</div>
        </div>
        <div class="agents-list">
          <template x-if="agents.length === 0">
            <div class="empty-agents">
              <div class="empty-agents-icon">ðŸ¤–</div>
              <div>No active agents</div>
            </div>
          </template>
          
          <template x-for="agent in agents" :key="agent.name">
            <agent-card
              :name="agent.name"
              :status="agent.status"
              :model="agent.model"
              :tokens-used="agent.tokensUsed"
              :tokens-total="200000"
              :cost="agent.cost"
              :active-tasks="agent.activeTasks"
              :tools-in-use="0"
              :messages="agent.messages"
              :errors="0"
              @agent-click="selectAgent($event.detail.agent)">
            </agent-card>
          </template>
        </div>
      </div>
      
      <!-- Center - Event Stream -->
      <div class="stream-main">
        <div class="stream-controls">
          <div class="filter-buttons">
            <button 
              class="filter-button" 
              :class="{ active: filterTypes.response }"
              @click="toggleFilterType('response')">
              ðŸ’¬ RESPONSE
            </button>
            <button 
              class="filter-button" 
              :class="{ active: filterTypes.tool }"
              @click="toggleFilterType('tool')">
              ðŸ”§ TOOL
            </button>
            <button 
              class="filter-button" 
              :class="{ active: filterTypes.thinking }"
              @click="toggleFilterType('thinking')">
              ðŸ’­ THINKING
            </button>
            <button 
              class="filter-button" 
              :class="{ active: filterTypes.hook }"
              @click="toggleFilterType('hook')">
              âš“ HOOK
            </button>
          </div>
          
          <div style="display: flex; gap: 0.75rem; align-items: center; flex-shrink: 0;">
            <search-bar @search="handleSearch"></search-bar>
            <auto-follow-toggle 
              :active="autoFollow.toString()"
              @toggle="autoFollow = $event.detail.active">
            </auto-follow-toggle>
          </div>
        </div>
        
        <event-stream 
          x-ref="eventStream"
          :auto-follow="autoFollow.toString()"
          :filter-agent="filterAgent"
          :filter-types="JSON.stringify(filterTypes)">
        </event-stream>
      </div>
      
      <!-- Right Sidebar - Agent Chat -->
      <div class="orchestrator-sidebar" :style="`width: ${rightWidth}px`">
        <div class="resize-handle resize-handle-right" 
             @mousedown="startResize($event, 'right')"></div>
        <orchestrator-panel x-ref="orchestratorPanel">
          <!-- Empty State -->
          <div x-show="!selectedAgent" style="display:flex;flex-direction:column;height:100%;align-items:center;justify-content:center;color:#666;gap:1rem;padding:2rem;text-align:center;">
            <div style="font-size:3rem;opacity:0.5;">ðŸ’¬</div>
            <div style="font-size:0.875rem;">Select an agent to open chat</div>
          </div>

          <!-- Chat Interface -->
          <template x-if="selectedAgent">
            <div style="display:flex;flex-direction:column;height:100%;">
              <!-- Header -->
              <div style="padding:1rem 1.5rem;background:#1a1a1a;border-bottom:1px solid #333;display:flex;align-items:center;justify-content:space-between;">
                <div style="display:flex;flex-direction:column;gap:0.25rem;">
                  <div style="font-size:0.875rem;font-weight:700;color:#e0e0e0;text-transform:uppercase;letter-spacing:0.05em;">
                    AGENT ACTIONS
                  </div>
                  <div style="display:flex;gap:1rem;font-size:0.75rem;font-family:'JetBrains Mono',monospace;">
                    <div style="display:flex;align-items:center;gap:0.25rem;color:#888;">
                      <span>Cost:</span>
                      <span style="color:#00d4ff;font-weight:600;" x-text="'$' + ((getAgentByName(selectedAgent)?.cost || 0).toFixed(4))"></span>
                    </div>
                    <div style="display:flex;align-items:center;gap:0.25rem;color:#888;">
                      <span>Context:</span>
                      <span style="color:#00d4ff;font-weight:600;" x-text="(getAgentByName(selectedAgent)?.tokensUsed || 0) + '/' + (getAgentByName(selectedAgent)?.tokensTotal || 200000)"></span>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Chat Messages -->
              <div style="flex:1;overflow-y:auto;overflow-x:hidden;padding:1rem;scroll-behavior:smooth;" x-ref="chatList">
                <template x-for="(msg, idx) in messagesByAgent[selectedAgent] || []" :key="selectedAgent + '-' + idx">
                  <chat-message
                    :type="msg.type"
                    :content="msg.content"
                    :timestamp="msg.ts"
                    :tool="msg.tool || ''"
                    :params="msg.params ? JSON.stringify(msg.params) : ''">
                  </chat-message>
                </template>
              </div>

              <!-- Chat Input -->
              <div style="padding:1rem;background:#0a0a0a;border-top:1px solid #333;">
                <textarea 
                  x-model="newMessage" 
                  @keydown.ctrl.enter="sendMessage"
                  @keydown.meta.enter="sendMessage"
                  placeholder="Type a message... (Ctrl+Enter to send)" 
                  class="chat-input-field"
                  :class="{ 'chat-input-focused': newMessage.trim() }">
                </textarea>
                <div style="display:flex;justify-content:flex-end;margin-top:0.75rem;">
                  <button 
                    @click="sendMessage" 
                    :disabled="!newMessage.trim()"
                    class="send-button"
                    :class="{ 'send-button-disabled': !newMessage.trim() }">
                    Send
                  </button>
                </div>
              </div>
            </div>
          </template>
        </orchestrator-panel>
      </div>
    </div>
  </div>

  <script>
    function dashboard() {
      return {
        ws: null,
        connectionStatus: 'connecting',
        autoFollow: true,
        filterAgent: '',
        filterTypes: {
          response: true,
          tool: true,
          thinking: true,
          hook: true
        },
        searchQuery: '',
              // chat state
      messagesByAgent: {},
      sessionIdByAgent: {},
      selectedAgent: null,
      newMessage: '',
      
      // resize state
      leftWidth: 300,
      rightWidth: 560,
      resizing: null,
      startX: 0,
      startWidth: 0,
      
      metrics: {
          activeAgents: 0,
          runningTasks: 0,
          logCount: 0,
          totalCost: 0
        },
        
        agents: [],
        
        init() {
          this.connectWebSocket();
          this.setupKeyboardShortcuts();
          this.setupResizeHandlers();
          
          // Setup search event listener
          const searchBar = document.querySelector('search-bar');
          if (searchBar) {
            searchBar.addEventListener('search', (e) => {
              this.handleSearch(e);
            });
          }
          
          // Update status bar pulse on new events
          this.$watch('metrics', () => {
            const statusBar = document.querySelector('status-bar');
            if (statusBar && this.connectionStatus === 'connected') {
              statusBar.triggerPulse();
            }
          });
        },
        
        connectWebSocket() {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}`;
          
          this.ws = new WebSocket(wsUrl);
          
          this.ws.onopen = () => {
            console.log('WebSocket connected');
          };
          
          this.ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              this.handleMessage(message);
            } catch (err) {
              console.error('Failed to parse message:', err);
            }
          };
          
          this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.connectionStatus = 'disconnected';
          };
          
          this.ws.onclose = () => {
            console.log('WebSocket disconnected');
            this.connectionStatus = 'disconnected';
            
            // Attempt reconnect after 5 seconds
            setTimeout(() => {
              this.connectWebSocket();
            }, 5000);
          };
        },
        
        handleMessage(message) {
          // Debug log every websocket message
          console.debug('[WS_RECV]', JSON.stringify(message));
          
          switch (message.type) {
            case 'init':
              this.handleInit(message.data);
              break;
            case 'event':
              this.handleEvent(message.data);
              break;
            case 'metrics':
              this.handleMetrics(message.data);
              break;
            case 'connection':
              this.connectionStatus = message.data.status;
              break;
            case 'clear':
              this.clearEvents();
              break;
          }
        },
        
        handleInit(data) {
          // Load initial events
          if (data.events && data.events.length > 0) {
            data.events.forEach(event => {
              this.handleEvent(event);
            });
          }

          // Populate sessionIdByAgent from initial metrics/agents if available
          const initialAgents = (data.metrics && data.metrics.agents) || data.agents || [];
          initialAgents.forEach(a => {
            if (a && a.name) {
              this.sessionIdByAgent[a.name] = a.sessionId || a.session_id || this.sessionIdByAgent[a.name];
              if (!this.messagesByAgent[a.name]) this.messagesByAgent[a.name] = [];
            }
          });
          
          // Load metrics
          if (data.metrics) {
            this.updateMetrics(data.metrics);
          }
          
          // Set connection status
          if (data.connectionStatus) {
            this.connectionStatus = data.connectionStatus;
          }
        },
        
        handleEvent(event) {
          // Skip GLOBAL_METRIC_SNAPSHOT from event displays - it only updates metrics
          if (event.type === 'GLOBAL_METRIC_SNAPSHOT') {
            return;
          }
          
          const stream = this.$refs.eventStream;

          // Add to main stream
          stream.appendEvent(event);

          // Maintain per-agent message list for chat
          const agentKey = event.agent || event.agent_name || event.name || 'unknown';
          if (!this.messagesByAgent[agentKey]) this.messagesByAgent[agentKey] = [];
          
          // Extract content based on event structure
          let content = '';
          if (event.content) {
            content = event.content;
          } else if (event.result) {
            // TOOL_RESPONSE events have result
            content = event.result;
          } else if (event.params) {
            // TOOL_CALL events have params - format nicely
            content = `Tool: ${event.tool}\n${JSON.stringify(event.params, null, 2)}`;
          } else if (event.text) {
            content = event.text;
          } else if (event.message) {
            content = event.message;
          } else {
            content = JSON.stringify(event);
          }
          
          this.messagesByAgent[agentKey].push({ 
            type: event.type, 
            content: content, 
            ts: event.timestamp || new Date().toISOString(),
            tool: event.tool,
            params: event.params
          });
          if (event.session_id) this.sessionIdByAgent[agentKey] = event.session_id;

          // Auto-follow: if enabled, select this agent when messages arrive
          if (this.autoFollow) {
            this.selectedAgent = agentKey;
            // scroll to bottom after DOM updates
            setTimeout(() => {
              const el = this.$refs.chatList;
              if (el) el.scrollTop = el.scrollHeight;
            }, 50);
          }
        },
        
        handleMetrics(data) {
          this.updateMetrics(data);
        },
        
        handleSearch(event) {
          this.searchQuery = event.detail.query || '';
          const stream = this.$refs.eventStream;
          if (stream) {
            stream.setAttribute('search-query', this.searchQuery);
          }
        },
        
        toggleFilterType(type) {
          this.filterTypes[type] = !this.filterTypes[type];
          // Trigger reactivity by updating the event stream attribute
          const stream = this.$refs.eventStream;
          if (stream) {
            stream.setAttribute('filter-types', JSON.stringify(this.filterTypes));
          }
        },
        
        updateMetrics(data) {
          this.metrics.activeAgents = data.activeAgents || 0;
          this.metrics.runningTasks = data.runningTasks || 0;
          this.metrics.logCount = data.logCount || 0;
          this.metrics.totalCost = data.totalCost || 0;
          
          if (data.agents) {
            this.agents = data.agents;
          }
        },
        
        clearAll() {
          if (confirm('Clear all events?')) {
            this.clearEvents();
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
              this.ws.send(JSON.stringify({ type: 'clear' }));
            }
          }
        },
        
        clearEvents() {
          const stream = this.$refs.eventStream;
          const panel = this.$refs.orchestratorPanel;
          stream.clear();
          panel.clear();
        },
        
        openPrompt() {
          alert('Prompt modal not yet implemented');
        },
        
        filterByAgent(agentName) {
          this.filterAgent = this.filterAgent === agentName ? '' : agentName;
          // TODO: Implement actual filtering logic
        },
        
        setupKeyboardShortcuts() {
          document.addEventListener('keydown', (e) => {
            // Cmd+K or Ctrl+K
            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
              e.preventDefault();
              this.openPrompt();
            }
          });
        }
        ,
        selectAgent(agentName) {
          this.selectedAgent = agentName;
          this.newMessage = '';
          // ensure chat scrolls to bottom
          setTimeout(() => {
            const el = this.$refs.chatList;
            if (el) el.scrollTop = el.scrollHeight;
          }, 50);
        },
        
        getAgentByName(name) {
          return this.agents.find(a => a.name === name);
        },
        
        sendMessage() {
          if (!this.selectedAgent) return alert('Select an agent first');
          const sessionId = this.sessionIdByAgent[this.selectedAgent];
          if (!sessionId) return alert('No session id for selected agent');
          const content = (this.newMessage || '').trim();
          if (!content) return;

          // Optimistically append
          if (!this.messagesByAgent[this.selectedAgent]) this.messagesByAgent[this.selectedAgent] = [];
          const msg = { type: 'USER_REQUEST', content, ts: new Date().toISOString() };
          this.messagesByAgent[this.selectedAgent].push(msg);

          // send to server
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify({ type: 'submit', session_id: sessionId, content }));
          } else {
            console.warn('WebSocket not open â€” cannot send message');
          }

          this.newMessage = '';
          setTimeout(() => {
            const el = this.$refs.chatList;
            if (el) el.scrollTop = el.scrollHeight;
          }, 50);
        },
        
        // Resize handlers
        startResize(event, side) {
          event.preventDefault();
          this.resizing = side;
          this.startX = event.clientX;
          this.startWidth = side === 'left' ? this.leftWidth : this.rightWidth;
          
          const handle = event.target;
          handle.classList.add('dragging');
        },
        
        setupResizeHandlers() {
          document.addEventListener('mousemove', (event) => {
            if (!this.resizing) return;
            
            const delta = event.clientX - this.startX;
            
            if (this.resizing === 'left') {
              const newWidth = Math.max(200, Math.min(600, this.startWidth + delta));
              this.leftWidth = newWidth;
            } else if (this.resizing === 'right') {
              const newWidth = Math.max(200, Math.min(600, this.startWidth - delta));
              this.rightWidth = newWidth;
            }
          });
          
          document.addEventListener('mouseup', () => {
            if (this.resizing) {
              const handles = document.querySelectorAll('.resize-handle');
              handles.forEach(h => h.classList.remove('dragging'));
              this.resizing = null;
            }
          });
        }
      };
    }
  </script>
</body>
</html>
